package compiler;

import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:

    /* Erros de sintaxe não fatais */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Erro Sintático");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" na linha " + (s.left+1));
                if (s.right >= 0)
                    m.append(", coluna " + (s.right+1));
            }
            if (s.value != null) {
                m.append(". Token inesperado: " + s.value);
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    /* Erros de sintaxe fatais */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/* --- Terminais --- */
terminal CLASS, ELSE, FI, IF, IN, INHERITS, ISVOID, LET, LOOP, POOL, THEN, WHILE;
terminal CASE, ESAC, NEW, OF, NOT;
terminal Boolean TRUE, FALSE;
terminal String ID, TYPEID;
terminal String STR_CONST;
terminal Integer INT_CONST;
terminal ASSIGN, DARROW, LE, LT, EQ;
terminal PLUS, MINUS, MULT, DIV, NEG, AT, DOT;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COLON, SEMI, COMMA;

/* --- Não-Terminais --- */
/* Declarados antes das regras para evitar erros de "Symbol not found" */
non terminal program;
non terminal class_list, class_decl;
non terminal feature_list, feature;
non terminal formal_list, formal;
non terminal expr_list, expr;
non terminal case_list, case_branch;
non terminal argument_list;
non terminal let_list;

/* --- Precedência de Operadores (da menor para a maior precedência) --- */
precedence right ASSIGN;
precedence left NOT;
precedence nonassoc LE, LT, EQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left ISVOID;
precedence left NEG;    // ~
precedence left AT;     // @
precedence left DOT;

/* --- Regras de Produção da Gramática --- */

start with program;

program ::= class_list
    {: System.out.println("Análise Sintática Concluída com Sucesso!"); :}
    ;

class_list ::= class_decl
    | class_list class_decl
    ;

class_decl ::= CLASS TYPEID:n LBRACE feature_list RBRACE SEMI
    {: System.out.println("Classe detectada: " + n); :}
    | CLASS TYPEID:n INHERITS TYPEID:p LBRACE feature_list RBRACE SEMI
    {: System.out.println("Classe detectada: " + n + " herda de " + p); :}
    ;

feature_list ::= /* vazio */
    | feature_list feature
    ;

feature ::=
      ID:name LPAREN formal_list RPAREN COLON TYPEID:type LBRACE expr RBRACE SEMI
      {: System.out.println(" - Método: " + name + " retorna " + type); :}
    | ID:name COLON TYPEID:type ASSIGN expr SEMI
      {: System.out.println(" - Atributo: " + name + " : " + type); :}
    | ID:name COLON TYPEID:type SEMI
      {: System.out.println(" - Atributo: " + name + " : " + type); :}
    ;

formal_list ::= /* vazio */
    | formal
    | formal_list COMMA formal
    ;

formal ::= ID:name COLON TYPEID:type
    ;

expr_list ::= expr SEMI
    | expr_list expr SEMI
    ;

case_list ::= case_branch
    | case_list case_branch
    ;

case_branch ::= ID:id COLON TYPEID:type DARROW expr SEMI
    ;

argument_list ::= expr
    | argument_list COMMA expr
    ;

let_list ::= ID COLON TYPEID
    | ID COLON TYPEID ASSIGN expr
    | let_list COMMA ID COLON TYPEID
    | let_list COMMA ID COLON TYPEID ASSIGN expr
    ;

expr ::=
      ID:id ASSIGN expr
    | expr AT TYPEID DOT ID LPAREN RPAREN
    | expr AT TYPEID DOT ID LPAREN argument_list RPAREN
    | expr DOT ID LPAREN RPAREN
    | expr DOT ID LPAREN argument_list RPAREN
    | ID LPAREN RPAREN
    | ID LPAREN argument_list RPAREN
    | IF expr THEN expr ELSE expr FI
    | WHILE expr LOOP expr POOL
    | LBRACE expr_list RBRACE
    | LET ID COLON TYPEID IN expr
    | LET ID COLON TYPEID ASSIGN expr IN expr
    | LET ID COLON TYPEID COMMA let_list IN expr
    | CASE expr OF case_list ESAC
    | NEW TYPEID
    | ISVOID expr
    | NEG expr
    | NOT expr
    | expr PLUS expr
    | expr MINUS expr
    | expr MULT expr
    | expr DIV expr
    | expr LT expr
    | expr LE expr
    | expr EQ expr
    | LPAREN expr RPAREN
    | ID
    | INT_CONST
    | STR_CONST
    | TRUE
    | FALSE
    ;